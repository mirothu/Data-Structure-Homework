A.本题考虑到面试者到达并就坐的顺序与最终面试顺序相反，因此使用了双向循环链表，并以逆时针就坐为后继的方向，顺时针面试为前驱的方向。
算法与一般的双向循环链表类似，通过声明node这个结构体并建立list类，添加一些操作的接口，如添加链表中的第一个节点，在链表的某个节点后加入一个节点等。其中最主要的是初始化时插入头节点，并让其前驱后继均指向NULL；在添加第一个节点时，将头节点的后继设为该节点，并让该节点的前驱后继均指向自身；在添加其他元素时，和普通链表无异。
而在决定添加节点的位置的算法上，我使用了计数器以及一个指向最后以为到达的面试者的指针，来方便我们的操作，每对正在操作的节点p进行一次取后继就将计数器gap-1，直到其为0，并在p的后面插入新的节点并将p指向它。
最终我们需要输出面试的顺序时，只需从最后一个面试者开始不断取前驱并输出其id即可。

B.这道题比较简单，完成中没有遇到较大的问题，只是在如何添加第一个节点进入循环链表上思考过一段时间。这道题在构建结构体节点node时主要参考了邓老师的讲义。

C.时间复杂度：每次添加节点的操作是O（m）的，而且共添加了n个节点，最终输出时的操作是O（1）的，因此总的时间复杂度应该为O(n*m)。
空间复杂度：主要空间用来存储各个节点，因此空间复杂度为O(n)的。