A.本题是求凸包的顶点，且需要逆时针输出，而考虑到我们采用的算法是逆时针进行查找的，因此我们需要用到队列，且为了方便操作，我们加入了从队尾出队这一接口。
在算法方面，我们使用了GrahamScan算法。
首先我们需要对读入的点进行排序并去掉重复的点，在这里我参考了一些资料，发现使用极角来排序由于出现共线的情况，会比较复杂，因此我使用了水平序排序，即以纵坐标为第一关键词，横坐标为第二关键词，实现了一个自定义的快排；之后我通过判断排序后的点列中第i个点和第i+j个点是否相同，是则仅留下相同点中的第一个，最终完成去重。
之后我们对去重后的点进行求凸包的运算，我们按排序后的下标顺序遍历，先让前两个点进入队列，之后按顺序进入队列，并不断判断队列中最后三个元素构成的两条射线的方向关系，即对X[k-2]与X[k-1]以及X[k-1]与X[k]构成的有向线段进行判断，若后一条射线相对前一条向右偏转或共线且更长则让X[k-1]出队，并进行下一次判断，直至队列元素不足三个或不满足之前的条件。
在进行完第一次遍历之后我们可以发现我们仅仅得到了凸包的右侧半条链，且纵坐标最大的点一定是此时队尾的元素。那么此时我们应该再进行一次逆序的遍历，用同样的操作得到左半链，为了避免对已经在右半链上的点进行重复的遍历，我们引入了指示器，当其已经在队列中时将其置为true，否则为false。同时为避免一些可能的bug，我们先将逆序循环时的第一个未访问点加入队列，即将其视为顺序遍历时的第二个点的作用然后继续操作。
有一个细节是我们在顺序遍历时将前两个点加入队列后，应该把第一个点的指示器设为false，便于之后逆序遍历时的判断，否则可能会出现得到的最后一个点与倒数第二个点以及第一个点的位置关系出现错误。
此后只需将队列中的点按顺序pop并打印坐标

B.在完成这道题的时候，我首先使用的是礼物包裹算法即JarvisMarch算法，但由于未排序且去重的点操作起来十分复杂，以及共线情况难以处理，在改完bug之后仍有超时或错误的点，因此我改用了GrahamScan算法。在参考资料时，看到有网友讲水平排序后的操作应按照横坐标的正负分为左右两段，然后进行遍历，但考虑到这道题的数据量以及逻辑的简明性，我没有采用这种方法，而是顺序加逆序遍历得到了最终的凸包。

C.空间复杂度：这道题使用了两个point类的数组来存储排序和去重后的点列，以及一个长度不超过去重后点的个数的队列，因此空间复杂度为O(n)。
时间复杂度：这道题中采用了快排的算法，时间复杂度为O(nlogn)，而诸如读取、输出、去重、出入队列的操作均为O（n）的，因此总的复杂度为O（nlogn）。