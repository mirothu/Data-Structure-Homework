A.本题是二叉搜索树的建立和遍历输出的问题，因此我们需要使用二叉树的数据结构。当然在建立二叉树前需要写一个二叉树的节点类。
主要算法是插入以及遍历输出的算法。
二叉搜索树的插入算法：由于左孩子的数据必然小于其父节点的数据，右孩子则为大于。因此我们在插入根节点后即可进行判断，若当前需要插入的数据小于根节点，则从根节点的左子树中寻找合适的位置插入。若我们找到了子树中的一个节点，使得当前需要插入的数据小于该节点的数据且其左孩子为空，则直接插入，否则对其左子树进行递归操作。最终肯定会在正确的位置上插入该数据。数据大于根节点时同理。
先序遍历：这里我们采用了讲义中的递归的算法，先访问根节点，输出数据，再递归到其左子树和右子树中，递归会在访问到空节点时返回。由此便完成了先序遍历。
后序遍历：后序遍历与先序遍历基本同理，但输出与递归的顺序变了，先递归左右子树，最后输出根节点的数据。

B.在完成这道题的时候，我遇到了一些低级的错误。
首先是在审题的时候没有注意到二叉搜索树的要求，将其当作了一颗普通的二叉树来进行插入。在这个过程中我使用了一条辅助队列，来按顺序记录当前左右孩子至少有一个为空的节点，每次先插入为队首元素的左孩子或右孩子并将其作为一个新的元素进入队列，且当队首元素左右孩子均不为空时出队，直到所有数据完成插入。在这个过程中我浪费了很多时间，是不应该的，以后应该注意。
其次是在完成使用二叉搜索树的规则进行插入的函数时遇到了一些逻辑上的问题，一开始没有想到使用递归，而是想用while循环遍历查找对应的位置，但最终没能完成，使用递归后思路简洁了很多。

C.空间复杂度：只需记录初始的数据并构建相应的二叉树节点，复杂度显然为O（n）。
时间复杂度：进行一次插入的操作的复杂度是与当前树的高度有关的，最坏情况下记为这n个节点在一条链上，即为O（h）的，h为当前树节点个数。最好的情况为O（logh），即插入的总的复杂度为O（nlogn）到O（n^2).而两种遍历的操作分摊后每个节点只需O（1）的时间，因此该遍历操作是O（n）的。总的来看，时间复杂度最坏情况下为O（n^2)。