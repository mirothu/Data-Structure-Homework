A.本题使用了最基本队列的结构。
主要需要实现的算法是实时获得队列中的最大值，而普通的遍历时间复杂度太高，因此我们通过参考讲义04-XA的内容，通过加入一个辅助的队列max，来存储对应位置及之后的数据的最大值。
核心的想法是读到E时将一个数据加入主队列stock时，从max队列的队尾开始逐步比较队中的数据与待插入的数据，直到max队列中某一位置的数据大于等于待插入的数据或访问到了max队列的header。而当主程序读到D时两个队列同时dequeue。

B.在第一次做这道题的时候，是通过每次遍历stock队列来得到最大值，但时间复杂度过高，且在写的过程中出现了一些bug，最终放弃了这一方法。在重新写的时候，整理好了思路便迎刃而解了。

C.空间复杂度：使用了两个队列，以及三个数组或字符串，因此空间复杂度为O（n）的。
时间复杂度：读入数据、出入队列以及输出都是O（n）的，主要的耗时在与更新max队列的内容，而其最差情况是每次操作为O（m）的，m为队列的规模，故最差情况下所有操作是O（n^2）的。