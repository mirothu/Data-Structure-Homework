A.本题中我使用了线段树这一数据结构，并实现了线段树中的单点修改和区间查询的算法。
线段树的生成中，我们以区间总长度n为参数，递归建立整个线段树，叶子节点代表的区间均为退化的单点。
其中单点修改的操作主要思路为：首先在树中查找到需要修改的点，并更改其状态（由于在节点类中我们用count值来代表整个区间中反面朝上的纸牌的数量，因此对于单点节点来说，0代表正面朝上，1代表反面朝上），并且更新该节点的父代节点的count值，具体操作为统一++或统一--。
区间查询的算法的主要思路为：将需要查询的区间[qstart,qend]分为数个可以直接返回count值的子区间，并将其相加即可得查询结果。而在这一功能中，我们引入了一个辅助的查询函数fuzhu_query(Segnode* tmpnode,int i , int j)，来实现递归查询，当tmpnode包含在[i,j]中时直接返回count值，当两者不交时返回0，而其他情况时我们递归查询其左右孩子与[i,j]的值，并相加得到最终的值。而此时我们得到的是反面朝上的纸牌数量，最终用（j-i+1）并减去该值即得到最终结果。

B.在本题中，我遇到的主要问题是如何实现区间查询，一开始并没有想到引入辅助函数来简化操作并进行递归，但后来参考了网络上线段树的查询算法，最终实现了递归。

C.空间复杂度：主要花费用于建立并存储有n个叶子节点的线段树，而有n个叶子节点的完全二叉树共包含不超过2n个节点，即空间复杂度为O（n）。

时间复杂度：创建线段树时需要逐一建立各个节点，这需要O（n）的时间；单次单点修改的操作首先在查找时需要O（logn）的时间，并在逐代更新count值时也需要O（logn）的时间，共O（logn）；区间查询的操作最好情况下仅需O（1），而最差情况下我们需要将整个区间[i,j]分为2*log_2(n/2)个小区间，而对每个小区间每次查询的复杂度不超过O(logn)，因此查询操作的总的复杂度不超过O（（logn）^2）。
在整个过程中共进行了m次操作，因此时间复杂度约为O(logn+m*(logn)^2)=O(m(logn)^2).